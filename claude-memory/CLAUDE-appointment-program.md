# 开发过程要求

## 前置准备

### 文档检阅要求
- **必须在每次开始设计、开发、测试等行为之前，重新检阅 @CLAUDE.md**
- 确保理解最新的项目规范和要求
- 检查是否有新的约定或变更

### 时间处理规范
- **获取实时时间**：必须在每一次要用到实时时间时，执行以下命令获取本地时间：
  ```python
  python -c "import datetime; print(datetime.datetime.today())"
  ```
- **禁止假设时间**：不要使用硬编码的时间或假设的日期
- **时间格式**：根据具体需求使用适当的时间格式

### 编码原则要求
作为专业开发工程师，必须内化并严格遵循以下核心编程原则，确保每次输出和建议都体现这些理念：

#### 🎯 核心编程原则
- **简单至上 (KISS)**: 追求代码和设计的极致简洁与直观，避免不必要的复杂性
- **精益求精 (YAGNI)**: 仅实现当前明确所需的功能，抵制过度设计和不必要的未来特性预留
- **杜绝重复 (DRY)**: 识别并消除代码或逻辑中的重复模式，提升复用性
- **坚实基础 (SOLID)**:
  - **S (单一职责)**: 各组件、类、函数只承担一项明确职责
  - **O (开放/封闭)**: 功能扩展无需修改现有代码
  - **L (里氏替换)**: 子类型可无缝替换其基类型
  - **I (接口隔离)**: 接口应专一，避免"胖接口"
  - **D (依赖倒置)**: 依赖抽象而非具体实现

#### 📋 原则应用要求
在设计、开发、测试的每个阶段都必须：
1. **主动识别**: 发现现有代码中违背原则的现象
2. **具体应用**: 明确说明如何在当前任务中体现原则
3. **效果验证**: 验证原则应用带来的具体好处（如代码量减少、可读性提高、扩展性增强）

### 复杂问题分析规范
- **问题复杂度识别**：当发现看似简单的问题实际包含多层含义、多个子目标或复杂业务逻辑时，必须使用分步思考方法
- **Sequential-Thinking MCP服务**：对于复杂问题，必须调用sequential-thinking MCP服务进行结构化思考分析
- **分步分析标准**：
  - 问题涉及多个技术领域或模块
  - 需求描述中隐含多个功能点
  - 实现路径存在多种可能性需要权衡
  - 涉及复杂的业务规则或约束条件
- **思考过程记录**：将分析过程和关键决策点记录到设计文档中

## 核心开发流程

遵循**设计优先**的开发原则，确保在编写代码前完成充分的流程设计：

```
检阅@CLAUDE.md → 程序流程设计 → 编写程序代码 → 测试验证 → 文档更新 → 提交变更
```

### 1. 程序流程设计阶段

采用迭代式设计方法，重复执行以下循环直至流程完全明确：

```
识别不明确点 → 分析决策 → 更新文档 → 验证完整性
```

#### 涉及文件
- **`CLAUDE.md`** - 项目指令和开发规范  
- **`program_flowchart/src`** - 程序流程图文档目录
- **`program_flowchart/png`** - 程序流程图 png 格式输出目录

#### 流程图组织结构
- **分层设计**：总览图作为入口点，复杂流程提取为独立模块
- **抽象接口**：复杂流程在总览图中抽象为 `输入 → [模块名] → 输出`
- **提取标准**：超过合理复杂度的流程（如多个决策分支）应独立成图

```
program_flowchart/src
├── 总览.txt              # 系统整体流程入口
└── ***.txt           # ***流程模块
```

#### 流程图规范
- **设计语言**：必须使用[plantuml](https://plantuml.com/zh/)进行流程图设计
- **及时生成**：必须在每一个流程图文件完成后立刻生成对应的png文件

#### 流程图生成命令

```bash
# 生成单个文件的png格式
java -jar "D:\service\my-tools\jar\plantuml.jar" program_flowchart/src/文件名.txt -tpng -o ../png

# 批量生成所有文件
java -jar "D:\service\my-tools\jar\plantuml.jar" program_flowchart/src -tpng -o ../png
```

### 2. 不明确点识别标准

在设计过程中主动识别并处理以下类型的问题：

#### 🔍 **歧义性问题**
- **识别标准**：存在多种可能的解释或实现方案
- **处理方式**：列举所有可能选项，明确询问用户选择

#### 🎯 **目的不明确**  
- **识别标准**：功能目标或业务需求表述模糊
- **处理方式**：分析可能的意图，提供选项供用户确认

#### ⚡ **优化机会**
- **识别标准**：当前方案可行但存在更优解决方案  
- **处理方式**：对比当前方案与优化方案的差异，征求用户意见

#### ❓ **未知问题处理**
- **识别标准**：遇到未知问题或非常模糊的情况
- **处理方式**：必须明确表示"我不知道"，并询问用户

### 3. 编码与测试阶段

#### 编码规范
- 遵循项目既定的代码风格和约定
- 优先重构现有代码而非重写
- 保持代码的可读性和可维护性

#### 编码原则应用规范
在编码阶段必须具体体现编程原则：
- **KISS原则应用**: 每个函数、类、模块都要保持功能单一和实现简洁
- **YAGNI原则应用**: 只实现当前迭代明确需要的功能，避免"也许以后需要"的设计
- **DRY原则应用**: 主动识别并抽象重复代码，创建可复用的函数和模块
- **SOLID原则应用**:
  - 确保每个类和函数职责单一
  - 使用抽象接口支持功能扩展
  - 保持接口设计的专一性
  - 依赖注入而非硬编码依赖
- **原则验证**: 每完成一个模块，验证其是否体现了相应原则，记录具体改进效果

#### 专业化代理选择规范
- **技术栈匹配原则**：完成设计阶段后，进入编码实现时，必须根据项目特点和技术要求选择最合适的专业化开发代理
- **Rust项目代理选择标准**：
  - **rust-cli-developer**：命令行工具、脚本程序、系统实用工具
  - **rust-web-developer**：Web服务、API开发、微服务架构
  - **rust-library-developer**：可复用组件、crate库、框架开发
  - **rust-crossplatform-developer**：跨平台应用、多平台兼容项目
  - **rust-performance-developer**：高性能系统、实时处理、性能优化项目
  - **rust-programmer**：通用Rust编程任务、功能模块实现
- **代理切换时机**：当项目需求发生变化或进入不同开发阶段时，应重新评估并切换到更合适的专业化代理
- **协作开发**：大型项目可以同时使用多个专业化代理分别负责不同模块的开发

#### 测试要求
- 编写单元测试覆盖核心功能
- 执行集成测试验证模块间交互
- 确保所有测试通过后才进入下一阶段

### 4. 设计完成验收标准

**✅ 设计阶段检查清单：**
- [ ] 总览流程图已绘制并涵盖所有主要功能
- [ ] 复杂模块已提取为独立流程图
- [ ] 各模块接口定义清晰（输入/输出/处理逻辑）
- [ ] 关键决策点已明确定义
- [ ] 异常处理路径已考虑
- [ ] 模块间依赖关系已明确

**注意：设计阶段必须完全通过上述检查后才能进入编码阶段**

## 版本控制与分支管理

### Git 工作流程

#### 分支策略
- **主分支(main/master)**：稳定的生产代码
- **功能分支(feature/xxx)**：新功能开发
- **修复分支(fix/xxx)**：错误修复
- **测试分支(test/xxx)**：测试验证

#### 分支规范
- 每个新的功能开发、功能修补、功能测试等，都要在单独的 Git 分支中进行开发
- 分支命名格式：`类型/简短描述`（如 `feature/add-user-auth`）
- 在该分支目标完成后再合并到主分支

### 提交与文档更新

#### 分步提交规范
在开发过程中必须遵循以下提交策略：

1. **任务开始检查**
   - 检查claude-memory目录下所有以CLAUDE开头的文件和now-task.md是否有未提交的变更
   - 如有未提交改动，分析改动内容并立即提交，在提交信息中描述当前状态

2. **步骤完成提交**
   - 每完成一个步骤的一批文档修改后，都要先进行仓库提交再进行下一步
   - 确保每个提交都是原子性的，只包含相关的变更
   - 提交信息要清晰描述完成的步骤和变更内容

3. **CHANGELOG维护检查**
   - 在每次提交前检查仓库变更状态，分析变更内容以决定是否需要对CHANGELOG进行修改
   - 不论是什么任务，都应该维护CHANGELOG记录重要变更

#### 完成后的必要操作
在项目开始时和每次设计、开发、测试完成后都必须：

1. **更新 CLAUDE.md**
   - 把相关的变动写入到 @CLAUDE.md 中
   - 记录新增的约定或规范
   - 更新已变更的流程或要求

2. **创建 Git 提交**
   - 编写清晰的提交信息
   - 遵循约定式提交规范（如：feat:、fix:、docs:、refactor:）
   - 确保提交的原子性（一个提交只做一件事）

3. **维护 Changelog**
   - 遵循[语义化版本](https://semver.mdn.cn/)规范
   - 记录版本号、日期、变更类型和内容
   - 更新 CHANGELOG.md 文件

4. **任务完成后清理**
   - 维护CHANGELOG并进行提交，在这一次提交之后：
     - 删除now-task.md中除了第一行之外的所有内容  
     - 删除undetermined.md文件（如存在）
     - 结束掉CHANGELOG中本次的Unreleased，分析应该更新哪一段版本号，更新相应的版本号，添加新的Unreleased

#### Changelog 维护规则

##### 开发阶段
- 所有新的变更都记录在 `[Unreleased]` 部分
- 每次功能开发、修复或变更后立即更新
- 保持 `[Unreleased]` 作为最新变更的临时容器

##### 版本发布时
- 将 `[Unreleased]` 改为具体版本号和日期（如 `[0.2.0] - 2025-01-30`）
- 创建新的空 `[Unreleased]` 部分供后续开发使用
- 使用 `git tag` 创建对应的版本标签

##### 版本号规则（语义化版本）
- **主版本号（MAJOR）**：不兼容的 API 变更
- **次版本号（MINOR）**：向下兼容的功能新增
- **修订号（PATCH）**：向下兼容的问题修复

#### Changelog 格式示例
```markdown
## [Unreleased]
### 新增 (Added) / 变更 (Changed) / 修复 (Fixed) / 移除 (Removed)
- 变更内容描述

## [版本号] - 日期
- 具体变更内容
```

## 质量保证要求

1. **文档同步**：代码变更时同步更新相关设计文档
2. **决策记录**：重要设计决策需在CLAUDE.md中记录原因  
3. **流程验证**：新功能开发前验证现有流程图的准确性
4. **代码审查**：合并前进行代码审查，确保质量
5. **回滚准备**：保持可回滚状态，记录回滚步骤
6. **编码原则检查**：定期检查代码是否违背KISS、YAGNI、DRY、SOLID原则
7. **原则效果跟踪**：记录应用编码原则后的具体改进效果（代码量、性能、可维护性等指标）