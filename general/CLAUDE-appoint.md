# 开发过程要求

## 前置准备

### 文档检阅要求
- **必须在每次开始设计、开发、测试等行为之前，重新检阅 @CLAUDE.md**
- 确保理解最新的项目规范和要求
- 检查是否有新的约定或变更

## 核心开发流程

遵循**设计优先**的开发原则，确保在编写代码前完成充分的流程设计：

```
检阅@CLAUDE.md → 程序流程设计 → 编写程序代码 → 测试验证 → 文档更新 → 提交变更
```

### 1. 程序流程设计阶段

采用迭代式设计方法，重复执行以下循环直至流程完全明确：

```
识别不明确点 → 分析决策 → 更新文档 → 验证完整性
```

#### 涉及文件
- **`CLAUDE.md`** - 项目指令和开发规范  
- **`program_flowchart/src`** - 程序流程图文档目录
- **`program_flowchart/png`** - 程序流程图 png 格式输出目录
- **`program_flowchart/txt`** - 程序流程图 txt 格式输出目录

#### 流程图组织结构
- **分层设计**：总览图作为入口点，复杂流程提取为独立模块
- **抽象接口**：复杂流程在总览图中抽象为 `输入 → [模块名] → 输出`
- **提取标准**：超过合理复杂度的流程（如多个决策分支）应独立成图

```
program_flowchart/src
├── 总览.txt              # 系统整体流程入口
└── ***.txt           # ***流程模块
```

#### 流程图规范
- **设计语言**：必须使用[plantuml](https://plantuml.com/zh/)进行流程图设计
- **及时生成**：必须在每一个流程图文件完成后立刻生成对应的png和txt文件

#### 流程图命令参考

> 下面的命令参考中，以 `program_flowchart/src/总览.txt` 作为示例源文件


```
# 帮助
java -jar "D:\service\my-tools\jar\plantuml.jar" -h

# 为 `program_flowchart/src/总览.txt` 生成 png 格式输出到 `program_flowchart/png/总览.png`
java -jar "D:\service\my-tools\jar\plantuml.jar" program_flowchart/src/总览.txt -tpng -o ../png

# 为 `program_flowchart/src/总览.txt` 生成 txt 格式输出到 `program_flowchart/png/总览.atxt`
java -jar "D:\service\my-tools\jar\plantuml.jar" program_flowchart/src/总览.txt -ttxt -o ../txt

# 为 `program_flowchart/src` 目录下所有文件生成 png 格式输出到 `program_flowchart/png`
java -jar "D:\service\my-tools\jar\plantuml.jar" program_flowchart/src -tpng -o ../png
```

### 2. 不明确点识别标准

在设计过程中主动识别并处理以下类型的问题：

#### 🔍 **歧义性问题**
- **识别标准**：存在多种可能的解释或实现方案
- **处理方式**：列举所有可能选项，明确询问用户选择

#### 🎯 **目的不明确**  
- **识别标准**：功能目标或业务需求表述模糊
- **处理方式**：分析可能的意图，提供选项供用户确认

#### ⚡ **优化机会**
- **识别标准**：当前方案可行但存在更优解决方案  
- **处理方式**：对比当前方案与优化方案的差异，征求用户意见

#### ❓ **未知问题处理**
- **识别标准**：遇到未知问题或非常模糊的情况
- **处理方式**：必须明确表示"我不知道"，并询问用户

### 3. 编码与测试阶段

#### 时间处理规范
- **获取实时时间**：必须在每一次要用到实时时间时，执行以下命令获取本地时间：
  ```python
  python -c "import datetime; print(datetime.datetime.today())"
  ```
- **禁止假设时间**：不要使用硬编码的时间或假设的日期
- **时间格式**：根据具体需求使用适当的时间格式

#### 编码规范
- 遵循项目既定的代码风格和约定
- 优先重构现有代码而非重写
- 保持代码的可读性和可维护性

#### 测试要求
- 编写单元测试覆盖核心功能
- 执行集成测试验证模块间交互
- 确保所有测试通过后才进入下一阶段

### 4. 设计完成标准

- [ ] 总览流程图已绘制并涵盖所有主要功能
- [ ] 复杂模块已提取为独立流程图
- [ ] 各模块接口定义清晰（输入/输出/处理逻辑）
- [ ] 关键决策点已明确定义
- [ ] 异常处理路径已考虑
- [ ] 模块间依赖关系已明确

## 版本控制与分支管理

### Git 工作流程

#### 分支策略
- **主分支(main/master)**：稳定的生产代码
- **功能分支(feature/xxx)**：新功能开发
- **修复分支(fix/xxx)**：错误修复
- **测试分支(test/xxx)**：测试验证

#### 分支规范
- 每个新的功能开发、功能修补、功能测试等，都要在单独的 Git 分支中进行开发
- 分支命名格式：`类型/简短描述`（如 `feature/add-user-auth`）
- 在该分支目标完成后再合并到主分支

### 提交与文档更新

#### 完成后的必要操作
在项目开始时和每次设计、开发、测试完成后都必须：

1. **更新 CLAUDE.md**
   - 把相关的变动写入到 @CLAUDE.md 中
   - 记录新增的约定或规范
   - 更新已变更的流程或要求

2. **创建 Git 提交**
   - 编写清晰的提交信息
   - 遵循约定式提交规范（如：feat:、fix:、docs:、refactor:）
   - 确保提交的原子性（一个提交只做一件事）

3. **维护 Changelog**
   - 遵循[语义化版本](https://semver.mdn.cn/)规范
   - 记录版本号、日期、变更类型和内容
   - 更新 CHANGELOG.md 文件

#### Changelog 维护规则

##### 开发阶段
- 所有新的变更都记录在 `[Unreleased]` 部分
- 每次功能开发、修复或变更后立即更新
- 保持 `[Unreleased]` 作为最新变更的临时容器

##### 版本发布时
- 将 `[Unreleased]` 改为具体版本号和日期（如 `[0.2.0] - 2025-01-30`）
- 创建新的空 `[Unreleased]` 部分供后续开发使用
- 使用 `git tag` 创建对应的版本标签

##### 版本号规则（语义化版本）
- **主版本号（MAJOR）**：不兼容的 API 变更
- **次版本号（MINOR）**：向下兼容的功能新增
- **修订号（PATCH）**：向下兼容的问题修复

#### Changelog 格式示例
```markdown
## [Unreleased]
### 新增 (Added)
- 开发中的新功能

## [0.2.0] - 2025-01-30
### 新增 (Added)
- 已发布的新功能描述

### 变更 (Changed)  
- 现有功能的变更

### 修复 (Fixed)
- 错误修复描述

### 移除 (Removed)
- 移除的功能

## [0.1.0] - 2025-01-29
### 新增 (Added)
- 初始版本功能
```

## 质量保证要求

1. **文档同步**：代码变更时同步更新相关设计文档
2. **决策记录**：重要设计决策需在CLAUDE.md中记录原因  
3. **流程验证**：新功能开发前验证现有流程图的准确性
4. **代码审查**：合并前进行代码审查，确保质量
5. **回滚准备**：保持可回滚状态，记录回滚步骤