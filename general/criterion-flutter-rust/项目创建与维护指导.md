# 项目创建与维护指导 - Flutter + Rust

## 1. 环境准备
- 安装 Flutter（3.22+，启用 wasm 支持需 3.22 以上）。
- 安装 Rust（toolchain stable，追加 `rustup target add aarch64-apple-ios x86_64-apple-darwin aarch64-linux-android` 等平台目标）。
- 安装 `cargo-ndk`、`cbindgen`、`wasm-pack`（WASM方案）及 `flutter_rust_bridge_codegen`。
- 准备包管理工具：`melos`（多包）、`just`（脚本）可选。

## 2. 项目骨架
```
project-root/
├── flutter_app/ (Flutter 工程)
├── rust_core/
│   ├── Cargo.toml
│   └── src/lib.rs
├── bridge/         # flutter_rust_bridge 生成文件，可嵌入flutter_app
├── scripts/
│   ├── build_rust.sh
│   ├── build_wasm.sh
│   └── ci_publish.dart
└── melos.yaml      # 可选
```

## 3. flutter_rust_bridge 快速搭建
1. 在 Flutter 工程中添加依赖：
   ```yaml
   dependencies:
     flutter_rust_bridge: ^2.0.0
   dev_dependencies:
     build_runner: ^2.4.0
   ```
2. 在 Rust crate 中引入 `flutter_rust_bridge`：
   ```toml
   [dependencies]
   flutter_rust_bridge = { version = "2", features = ["stream"] }
   anyhow = "1"
   serde = { version = "1", features = ["derive"] }
   ```
3. 定义桥接函数（`rust_core/src/api.rs`）：
   ```rust
   use anyhow::Result;

   pub fn heavy_calculation(input: Vec<f64>) -> Result<f64> {
       Ok(input.iter().sum())
   }
   ```
4. 运行 `flutter_rust_bridge_codegen` 生成 Dart 与 Rust 桥接文件。
5. 在 Flutter 侧封装 service：
   ```dart
   final api = RustImpl();
   Future<double> calculate(List<double> input) => api.heavyCalculation(input: input);
   ```
6. 配置构建脚本（`scripts/build_rust.sh`）编译各平台动态库并复制至 `flutter_app/ios/`、`android/src/main/jniLibs/` 等目录。

## 4. FFI / UniFFI 方案扩展
- 使用模板 `flutter-rust-ffi`：可直接在 `rust_core` 中导出 C 函数并在 Dart 层通过 `DynamicLibrary` 绑定。
- UniFFI：在 `rust_core/src` 定义 `.udl` 描述，运行 `uniffi-bindgen` 生成 Swift/Kotlin/FFI 代码，再由 Flutter 调用。

## 5. WASM 方案（Flutter Web）
1. 在 Rust crate 添加 wasm 目标：`wasm-pack build --target web`。
2. 将生成的 `pkg/` 拷贝至 Flutter Web 项目 `web/wasm/`，编写 JS loader。
3. Flutter Web 端使用 `dart:js_interop` 调用 wasm 导出函数（Dart 3.2+）。
4. 设置 `flutter build web --wasm` 生成产物，部署到支持 HTTP/2 的 CDN。

## 6. 桌面与 Tauri 混合
- 若需桌面应用利用 Tauri：
  1. 使用 `tauri init --before "pnpm create tauri-app"` 创建基座，引入 Flutter Web build 作为前端，Rust 负责命令处理。
  2. Flutter 桌面也可直接启用 `flutter run -d windows`；在 Tauri 中启动 Flutter Web build 以复用 UI。
- 使用 HTTP/WebSocket 或 `invoke` 调用 Tauri 命令，确保线程安全。

## 7. CI/CD 流程
- GitHub Actions 示例：
  - matrix 编译 Rust 动态库（iOS/macOS/Android/Windows/Linux/wasm）。
  - 运行 `flutter test`、`cargo test`、`melos run analyze`。
  - 打包发布时执行平台特定打包命令（fastlane、codemagic CLI）。
- 缓存 cargo/Flutter 依赖，加速构建。

## 8. 调试与故障排查
- Rust 端启用 `RUST_LOG=debug`、使用 `tracing` 输出结构化日志。
- Flutter 端使用 `DevTools`、`logger` 捕获异常；结合 Crashlytics/Sentry 上报。
- 遇到平台差异：
  - iOS 需添加 Swift bridging header；
  - Android 需在 `CMakeLists.txt` 设置 ABI；
  - Windows/Linux 注意 MSVC vs GNU toolchain 匹配。

## 9. 运维与升级
- 定期更新 `flutter_rust_bridge`、Rust toolchain；关注 GitHub issue （性能/内存）反馈。
- 使用 `cargo audit`、`flutter pub outdated` 检查依赖安全。
- 长期维护时建立文档：记录如何生成桥接代码、如何在本地/CI运行、如何发布新版本。

## 10. 决策指引
- 性能敏感 → 优先 FlutterRustBridge / 纯 FFI。
- 需要跨平台共享算法（含Web） → Rust WASM。
- 桌面轻量化、系统集成 → Tauri。
- 多语言共享逻辑 → UniFFI。
- 可以并行采用多方案：例如移动端使用 FRB，Web 使用 WASM，桌面使用 Tauri，保持 Rust 核心逻辑一致。
