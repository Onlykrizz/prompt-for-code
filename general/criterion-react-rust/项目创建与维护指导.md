# 项目创建与维护指导 - React(TypeScript) + Rust

## 1. 环境准备
- Node.js / pnpm（或 Yarn）用于 React 脚手架。
- Rust stable + `rustup target add wasm32-unknown-unknown`（WASM方案）、`cargo install wasm-pack`、`cargo-watch`。
- 可选：`typeshare`/`typify`（共享类型）、`just`（脚本）、`docker`（部署）。

## 2. 项目结构建议
```
fullstack/
├── apps/
│   ├── web/           # React(Vite/Next)
│   └── desktop/       # Tauri (可选)
├── crates/
│   ├── core/          # 纯Rust业务逻辑
│   ├── api/           # Axum/Actix服务
│   └── wasm/          # wasm-bindgen目标
├── shared/
│   └── types/         # typify/serde共享类型
├── scripts/
│   ├── build_wasm.sh
│   ├── start_api.sh
│   └── ci_pipeline.yml
└── pnpm-workspace.yaml / Cargo.toml
```

## 3. Rust 服务端 + React 前端
1. 初始化 Axum 项目：`cargo new crates/api --bin`，引入 `axum`, `serde`, `sqlx`。
2. 定义 API 与共享类型（`shared/types/src/lib.rs`），使用 `typeshare` 生成 TS 类型：
   ```bash
   cargo install typeshare-cli
   typeshare ./shared/types/src --lang=ts --output=apps/web/src/types/shared.ts
   ```
3. React 项目（Vite+TS）：`pnpm create vite web --template react-ts`。
4. 使用 `axios`/`@tanstack/query` 调用 API，封装 service 层。
5. CI：
   - `cargo fmt && cargo clippy -- -D warnings`
   - `cargo test`
   - `pnpm lint && pnpm test && pnpm build`
6. 部署：将 Rust 服务部署到容器或Serverless，前端部署到 CDN；可使用 `Dockerfile` 统一构建。

## 4. WASM 方案（在 React 中调用 Rust）
1. 在 `crates/wasm` 使用 `wasm-pack build --target bundler --out-dir pkg`。
2. React/Vite 配置：
   ```ts
   const wasm = await import("../pkg/app_bg.wasm");
   const result = wasm.heavy_calculation(inputArray);
   ```
3. 若需在 Web Worker 中执行：使用 `Comlink` 或原生 Worker，将 wasm 调用放入 worker，主线程监听消息。
4. Next.js 中通过 `dynamic(() => import('...'), { ssr: false })` 加载
enableEdgeRuntime 需考虑 wasm 支持情况。

## 5. Tauri 桌面方案
1. `pnpm create tauri-app` 或 `pnpm create tauri-app --vanilla` + React Vite。
2. 在 `src-tauri` 中实现 Rust 命令：
   ```rust
   #[tauri::command]
   async fn calculate(data: Vec<f64>) -> Result<f64, String> {
       Ok(data.iter().sum())
   }
   ```
3. React 端通过 `@tauri-apps/api/tauri` 调用：
   ```ts
   const result = await invoke<number>("calculate", { data });
   ```
4. CI 使用 `tauri-action` 打包 `.msi/.dmg/.AppImage`；对 Windows 需签名证书。

## 6. Dioxus/Hybrid
- 若将 Rust 作为主要UI：使用 Dioxus 0.7；React 可作为外部壳或迁移参考。
- 记录用户反馈：部分开发者认为尚不成熟，应评估团队接受度。

## 7. 调试与监控
- Rust 服务端：`tracing` + OpenTelemetry；部署 Grafana/Jaeger。
- React：`Sentry`/`Datadog RUM` + Web Vitals；SSR/Edge 设置 `Next.js` 性能分析。
- WASM：在 DevTools Performance 面板分析主线程时间，必要时启用 Profiler。
- Tauri：配置 `RUST_LOG=debug`，使用 `tauri::plugin::log` 输出日志。

## 8. 安全与版本管理
- Rust 依赖 `cargo audit`；Node 依赖 `pnpm audit`。
- 环境变量集中在 `.env`（Next.js 需区分 `NEXT_PUBLIC_` 与 server 端变量）。
- 明确跨域策略：服务端配置 CORS，中间层 (API Gateway) 统一管理。

## 9. 发布流程建议
- GitHub Actions pipeline：
  - Step1：`cargo fmt`, `cargo clippy`, `cargo test`
  - Step2：`wasm-pack build`、`pnpm test`、`pnpm build`
  - Step3：如启用 Tauri，运行 `pnpm tauri build`
  - Step4：Push artifacts / draft release。
- 可使用 Monorepo 工具（Turborepo、Nx）共享缓存。

## 10. 决策建议
- **有后台服务需求** → Axum/Actix + React。
- **前端需离线计算** → Rust → WASM（配合 Web Worker）。
- **桌面/本地化** → Tauri 2 + Rust 命令系统。
- **全Rust堆栈尝试** → Dioxus/Leptos（需评估成熟度）。
- 可组合使用：例如 Web 端使用 WASM，桌面端使用 Tauri，同一 Rust 核心通过 `cfg` 分支适配。
